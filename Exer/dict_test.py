thisdict = {
    "brand": "Ford",
    "electric": False,
    "year": 1964,
    "colors": ["red", "white", "blue"]
}

# print(thisdict)
# print(len(thisdict))
# print(type(thisdict))
# b = thisdict.items()
# print(b)

# # !! обязательно проверить как происходит вывод на печать (удивило)
# x = thisdict.keys()
# y = thisdict.values()
#
# print(x, y, sep='\n')
# ------------------------------------------------------------

# car = {
# "марка": "Ford",
# "модель": "Mustang",
# "год": 1964
# }
# a = car.values()
# print(a) #before the change
# car["год"] = 2020
# print(a) #after the change
#
# # !!!! Посмотреть как происходит вывод items()
# bb = car.items()
# print(bb)

# --------------------------------------------------------------------
# !! объединение словарей, так же можно обновить значение элемента, так как затирает прошлое значение клча
# при совпадении ключей

# thisdt = {
#   "марка": "Ford",
#   "модель": "Mustang",
#   "год": 1964
# }
# print(thisdt)
# thisdt.update({"год": 2020, "цвет": "White"})
# print(thisdt)
# -------------------------------------------------------------------
# УДАЛЕНИЕ ЭЛЕМЕНТОВ
# thisdict = {
#   "марка": "Ford",
#   "модель": "Mustang",
#   "год": 1964
# }
# # thisdict.pop("модель")
# print(thisdict)

# -------------------------------------------------------------------
# popitem()Метод удаляет последний вставленный элемент (в версиях до 3.7 вместо него
# удаляется случайный элемент)
# thisdict = {
#   "марка": "Ford",
#   "модель": "Mustang",
#   "год": 1964
# }
# thisdict.popitem()
# print(thisdict)

# ---------------------------------------------------------------------
# ЦИКЛЫ СЛОВАРЕЙ
# thisdt = {
#   "марка": "Ford",
#   "модель": "Mustang",
#   "год": 1964
# }
# print(thisdt)
# thisdt.update({"год": 2020, "цвет": "White"})
#
# for x in thisdt:
#     ''' интересный вывод ключа и значения'''
#     print(x, end=" ")
#     print(thisdt[x])
# print('++++++++++++++++++++++++++++')
# for x, y in thisdt.items():
#     '''Но правильно делать так'''
#     print(x, y)

# ---------------------------------------------------------------------
# КОПИРОВАНИЕ СЛОВАРЕЙ
# Вы не можете скопировать словарь, просто набрав dict2 = dict1, потому что: dict2будет только ссылкой dict1,
# и изменения, внесенные в dict1, также будут автоматически внесены dict2.
# Есть способы сделать копию, один из способов - использовать встроенный метод словаря copy().

# thisdict = {
#     "марка": "Ford",
#     "модель": "Mustang",
#     "год": 1964
# }
# mydict = thisdict.copy()
# mydict_2 = thisdict
# print('mydict -- ', mydict)
# mydict.update({'двигатель': 'V6', 'цвет': 'Black'})
# print('mydict -- ', mydict)
# print('thisdict -- ', thisdict)
#
# mydict_2['привод'] = '4х4'
# '''
# !!! ОБРАТИ ВНИМАНИЕ ЧТО ПРИ ДОБАВЛЕНИИ ЭЛЕМЕНТА ОН ДОБАВИТСЯ И В ПЕРВОНАЧАЛЬНЫЙ СЛОВАРЬ,
#  ТАК КАК НЕКОРРЕКТНО СДЕЛАЛИ ЧЕРЕЗ ПРИСВАИВАНИЕ ВТОРОЙ ВАРИАНТ, А ПЕРВЫЙ ЧЕРЕЗ copy() создает реально отдельную копии/
#  новый объект (а не делает ссылку на первоначальный)
# '''
# print('thisdict -- ', thisdict)
#
# ''' еще правильный вариант копирования словаря'''
# mydict_3 = dict(mydict)
# print('mydict_3 -- ', mydict_3)
# mydict_3['вес'] = 1.300
# print('mydict -- ', mydict)
# print('mydict_3 -- ', mydict_3)

# ---------------------------------------------------------------------
# ВЛОЖЕННЫЕ СЛОВАРИ !!!!!!!!!! Интересная реализация
myfamily = {
    "child1": {
        "имя": "Эмиль",
        "год": 2004
    },
    "child2": {
        "имя": "Тобиас",
        "год": 2007
    },
    "child3": {
        "имя": "Линус",
        "год": 2011
    }
}
print('myfamily   -- ', myfamily)

'''ИЛИ можно так'''

child1 = {
    "имя": "Эмиль",
    "год": 2004
}
child2 = {
    "имя": "Тобиас",
    "год": 2007
}
child3 = {
    "имя": "Линус",
    "год": 2011
}

myfamily_1 = {
    "child1": child1,
    "child2": child2,
    "child3": child3
}
print('myfamily_1 -- ', myfamily_1)
